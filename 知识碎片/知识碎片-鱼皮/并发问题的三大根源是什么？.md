# 并发问题的三大根源是什么？

> 作者：[130.](https://www.code-nav.cn/user/1613530088253423618/info)，[编程导航星球](https://wx.zsxq.com/dweb2/index/group/51122858222824) 编号 14793

## 1. 前言

从[一文了解进程与线程](https://articles.zsxq.com/id_1lqk669aru6k.html)中我们了解到，一个任务中CPU的的运算速度要远远大于IO的速度，当CPU和IO一起协作时就容易产生问题，一个任务在等待IO的时候，CPU无法进行工作，所以后续为了提高CPU的利用率，进程中诞生线程，CPU添加缓存，编译程序优化指令执行次序，使得缓存能够得到更加合理地利用，但是与之而来的，还有大量的并发问题。

## 2. CPU缓存导致的可见性

在早期CPU是单核的时候，所有线程都在一个CPU上执行，CPU的缓存与内存之间的数据一致性就很好解决了。CPU高速缓存是用于减少CPU访问内存所需的时间，提高CPU的使用率，一个线程的操作对于另一个线程来说是一定可以看到的。一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为**可见性**

![](https://pic.yupi.icu/5563/202403152110832.png)

随着时间的发展，CPU变为多核的时候，由于CPU都有自己独立的缓存，当多个线程分别在不同的CPU上执行时，会把内存中操作的变量复制到自己的CPU缓存中，处理完成后在写入内存，这样线程之间的可见性就无法保障了。

![](https://pic.yupi.icu/5563/202403152110838.png)

下面通过一段代码来验证可见性问题：
```java
public class Test {

    private static long sum = 0;

    public static void main(String[] args) throws InterruptedException {

        // 创建两个线程，每个线程对sum进行加10000的操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                sum++;
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                sum++;
            }
        });

        t1.start();
        t2.start();

        // 等待两个线程执行结束
        t1.join();
        t2.join();
        System.out.println(sum);
    }
}
```
通过看代码，直觉告诉我们最后输出结果是20000，但是当实际运行时，我们发现每次的输出结果都是小于20000的。

我们假设两个线程同时执行，把`sum = 0`加载到自己的CPU缓存中，t1 t2两个线程进行`sum++`
的操作，此时各自缓存中的sum值都是1，这时候把sum写入到内存的时候，我们发现不是我们期望的2，而是1。

## 3. 线程切换导致的原子性问题

我们知道线程是通过获取CPU时间片来进行调度的，线程只有得到CPU时间片才能执行指令，处于执行状态，没有得到时间片的线程处于就绪状态，等待系统分配下一个CPU时间片。

线程的调度模型目前主要分为两种：**分时调度模型**和**抢占式调度模型**。

1. 分时调度模型：系统平均分配CPU时间片，所有线程轮流获取CPU时间片.

2. 抢占式调度：系统按照线程优先级分配CPU时间片。优先级高的线程优先分配CPU时间片，如果所有就绪线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些。

Java的线程调度模型采用的就是抢占式调度。

我们知道所有的高级编程语言，都需要转换成CPU指令，这样CPU才能执行操作。就对于上述`sum++`这一行操作，转换成CPU指令后，至少有三条：

1. 将sum变量从内存中加载到CPU寄存器。
2. 在寄存器中执行+1操作。
3. 将sum变量写入到缓存中

当执行第1步的时候，一个线程的时间片消耗完了，发生了线程切换，最后也会导致最终的结果是1而不是2.

![](https://pic.yupi.icu/5563/202403152110479.png)

我们看代码是一行，就感觉是一步就完成了，其实被分成这么多条CPU指令，上述问题中的任务切换，还有可能发生在任何一步，所以我们在编程时需要注意代码层面的**原子性 ：一个或者多个操作在 CPU 执行的过程中不被中断的特性**。

## 4. 编译优化导致的有序性问题

之前我们了解到CPU增加高速缓存，进程中诞生线程等等为了提高CPU利用率的方式，其实在CPU内部执行CPU指令时，会调整每一步CPU指令的执行顺序，来提升CPU的效率。指令顺序优化可能发生在**编译**、**CPU指令执行**、**缓存优化**几个阶段，其优化原则就是只要能保证重排序后不影响单线程的运行结果，那么就允许指令重排序的发生。

一个对象的new操作，也不是原子性的，他分为下面三步：

1. 给对象分配内存
2. 在这块内存上初始化对象
3. 将这块地址赋值给变量

```java
public class Singleton {

    private static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

在这个不正确的单例模式中，我们假设A B两个线程同时调用`getInstance`方法，同时发现`instance == null`，但是有可能因为指令优化，导致并不是按照正常123的顺序，当发生132的顺序时，可能会出现下面的情况

![](https://pic.yupi.icu/5563/202403152111908.png)

这时候可能就会发生空指针异常了，我们使用idea时，idea会提醒你为`instance`变量添加
`volatile`变量，主要是为了解决上述的问题。之后我们再详细介绍Java是如何解决这三大问题的。